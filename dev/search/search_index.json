{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"<code>ropt-everest</code>","text":"<p>The <code>ropt-everest</code> plugin extends <code>ropt</code> with functionality specific to Everest. It provides the ability to load custom Python code to override the default optimization workflow. These custom workflows can either be run via the standard Everest command line interface (cli), or via a script that bypasses the Everest cli.</p>"},{"location":"reference/reference/","title":"Reference","text":""},{"location":"reference/reference/#ropt_everest.load_config","title":"ropt_everest.load_config","text":"<pre><code>load_config(config_file: str) -&gt; dict[str, Any]\n</code></pre> <p>Loads an Everest configuration from a YAML file.</p> <p>This function reads an Everest configuration specified by the <code>config_file</code> path, parses it, and returns it as a Python dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>The path to the Everest configuration YAML file.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representing the Everest configuration.</p>"},{"location":"reference/reference/#ropt_everest.create_optimizer","title":"ropt_everest.create_optimizer","text":"<pre><code>create_optimizer(evaluator: Evaluator) -&gt; EverestOptimizer\n</code></pre> <p>Creates an optimizer.</p> <p>This function returns an <code>EverestOptimizer</code> object, which you can execute using its <code>run</code> method.</p> <p>Returns:</p> Type Description <code>EverestOptimizer</code> <p>An <code>EverestOptimizer</code> object, representing the added optimizer.</p>"},{"location":"reference/reference/#ropt_everest.create_ensemble_evaluator","title":"ropt_everest.create_ensemble_evaluator","text":"<pre><code>create_ensemble_evaluator(\n    evaluator: Evaluator,\n) -&gt; EverestEnsembleEvaluator\n</code></pre> <p>Create an ensemble evaluator.</p> <p>Invoking this function returns an <code>EverestEnsembleEvaluator</code> object, which you can execute using its <code>run</code> method.</p> <p>Returns:</p> Type Description <code>EverestEnsembleEvaluator</code> <p>An <code>EverestEnsembleEvaluator</code> object, representing the added evaluator.</p>"},{"location":"reference/reference/#ropt_everest.run_everest","title":"ropt_everest.run_everest","text":"<pre><code>run_everest(\n    config_file: str,\n    *,\n    script: Path | str | None = None,\n    report_exit_code: bool = True,\n) -&gt; EverestExitCode\n</code></pre> <p>Runs an Everest optimization directly from a configuration file.</p> <p>This function provides a convenient way to execute an Everest optimization workflow without having to use the <code>everest</code> command. This method will run a full optimization, but it will not produce the usual monitoring output of Everest.</p> <p>Using this method instead of the <code>everest</code> command-line tool offers several advantages, including:</p> <ul> <li>Direct access to standard output (stdout): Unlike the <code>everest</code>     command, this does not redirect standard output.</li> <li>Error traces: If errors occur during the optimization, you'll get a     full Python stack trace, making debugging easier.</li> <li>Exceptional exit conditions, such as maximum number batch reached, or     a user abort are reported, if <code>report_exit_code</code> is set (the default).</li> </ul> <p>The optional <code>script</code> argument is used to define a custom script that runs the optimization. If the file named by <code>script</code> does not exists, the argument is ignored and the default optimization workflow is run.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>The path to the Everest configuration file (YAML).</p> required <code>script</code> <code>Path | str | None</code> <p>Optional script to replace the default optimization.</p> <code>None</code> <code>report_exit_code</code> <code>bool</code> <p>If <code>True</code>, report the exit code.</p> <code>True</code> <p>Returns:</p> Type Description <code>EverestExitCode</code> <p>The Everest exit code.</p>"},{"location":"reference/reference/#ropt_everest.EverestOptimizer","title":"ropt_everest.EverestOptimizer","text":"<p>               Bases: <code>HandlerMixin</code>, <code>DefaultOptimizerComputeStep</code></p> <p>The Everest optimizer class.</p> <p>This  class executes an optimization via the default Everest code path. An <code>EverestOptimizer</code> object is most conveniently created via the <code>create_optimizer</code> function.</p> <p>Call <code>run</code> method to execute the optimizer. Refer the the documentation of the <code>HandlerMixin</code> class for more information on methods that are used to add event handlers to an optimizer.</p>"},{"location":"reference/reference/#ropt_everest.EverestOptimizer.__init__","title":"__init__","text":"<pre><code>__init__(*, evaluator: Evaluator) -&gt; None\n</code></pre> <p>Initialize an Everest optimizer.</p> <p>Parameters:</p> Name Type Description Default <code>evaluator</code> <code>Evaluator</code> <p>The evaluator object to run function evaluations.</p> required"},{"location":"reference/reference/#ropt_everest.EverestOptimizer.run","title":"run","text":"<pre><code>run(\n    config: dict[str, Any],\n    *,\n    controls: ArrayLike | None = None,\n    metadata: dict[str, Any] | None = None,\n    output_dir: str | None = None,\n) -&gt; ExitCode\n</code></pre> <p>Runs the optimizer.</p> <p>This method executes the optimizer with the given parameters.</p> <p>config: The <code>config</code> dictionary should be a dictionary that can be validated as an <code>EverestConfig</code> object.</p> <p>controls: If no controls are provided, the optimizer will use the initial values from the configuration.</p> <p>metadata: The <code>metadata</code> parameter allows you to associate arbitrary data with each result generated by the evaluator. This metadata is included in generated tables and data frames. The keys in the <code>metadata</code> dictionary are used as column names in the output tables.</p> <p>optimization_output: Normally, the optimizer's output is directed to the <code>optimization_output</code> subdirectory within the main output directory specified in the Everest configuration. When multiple optimization or ensemble evaluation steps are executed, there's a risk of output files being overwritten. The <code>output_dir</code> argument provides a way to override the default output location. You can specify an absolute path, or a relative path, which will be interpreted as relative to the <code>optimization_output</code> directory.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any]</code> <p>An optional dictionary containing the Everest         configuration. If omitted, the default configuration is         used.</p> required <code>controls</code> <code>ArrayLike | None</code> <p>An array-like object containing the controls for the optimization.</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>An optional dictionary of metadata to associate with the         results.</p> <code>None</code> <code>output_dir</code> <code>str | None</code> <p>An optional output directory.</p> <code>None</code>"},{"location":"reference/reference/#ropt_everest.EverestEnsembleEvaluator","title":"ropt_everest.EverestEnsembleEvaluator","text":"<p>               Bases: <code>HandlerMixin</code>, <code>DefaultEnsembleEvaluatorComputeStep</code></p> <p>The Everest ensemble evaluator class.</p> <p>This  class evaluates an ensemble for one or more control values via the default Everest code path. An <code>EverestEnsembleEvaluator</code> object is most conveniently created via the <code>create_ensemble_evaluator</code> function.</p> <p>Call <code>run</code> method to execute the evaluator. Refer the the documentation of the <code>HandlerMixin</code> class for more information on methods that are used to add event handlers to an ensemble evaluator.</p>"},{"location":"reference/reference/#ropt_everest.EverestEnsembleEvaluator.__init__","title":"__init__","text":"<pre><code>__init__(*, evaluator: Evaluator) -&gt; None\n</code></pre> <p>Initialize a default optimizer.</p> <p>Parameters:</p> Name Type Description Default <code>evaluator</code> <code>Evaluator</code> <p>The evaluator object to run function evaluations.</p> required"},{"location":"reference/reference/#ropt_everest.EverestEnsembleEvaluator.run","title":"run","text":"<pre><code>run(\n    config: dict[str, Any],\n    *,\n    controls: ArrayLike | None = None,\n    metadata: dict[str, Any] | None = None,\n    output_dir: str | None = None,\n) -&gt; ExitCode\n</code></pre> <p>Runs the ensemble evaluator.</p> <p>This method executes the underlying ensemble evaluator with the given parameters:</p> <p>config: The <code>config</code> dictionary should be a dictionary that can be validated as an <code>EverestConfig</code> object.</p> <p>controls: The <code>controls</code> parameter can be a single vector, a sequence of multiple vectors, or a 2D matrix where the control vectors are the rows. If no controls are provided, the evaluator will use the initial values from the configuration.</p> <p>metadata: The <code>metadata</code> parameter allows you to associate arbitrary data with each result generated by the evaluator. This metadata is included in generated tables and data frames. The keys in the <code>metadata</code> dictionary are used as column names in the output tables.</p> <p>optimization_output: Normally, the optimizer's output is directed to the <code>optimization_output</code> subdirectory within the main output directory specified in the Everest configuration. When multiple optimization or ensemble evaluation steps are executed, there's a risk of output files being overwritten. The <code>output_dir</code> argument provides a way to override the default output location. You can specify an absolute path, or a relative path, which will be interpreted as relative to the <code>optimization_output</code> directory.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any]</code> <p>An optional dictionary containing the Everest         configuration. If omitted, the default configuration is         used.</p> required <code>controls</code> <code>ArrayLike | None</code> <p>An array-like object containing the controls to evaluate.</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>An optional dictionary of metadata to associate with the         results.</p> <code>None</code> <code>output_dir</code> <code>str | None</code> <p>An optional output directory.</p> <code>None</code>"},{"location":"reference/reference/#ropt_everest.HandlerMixin","title":"ropt_everest.HandlerMixin","text":"<p>Mixin class for adding event handlers to an optimizer or ensemble evaluator.</p>"},{"location":"reference/reference/#ropt_everest.HandlerMixin.add_tracker","title":"add_tracker","text":"<pre><code>add_tracker(\n    *,\n    what: Literal[\"best\", \"last\"] = \"best\",\n    constraint_tolerance: float | None = None,\n) -&gt; EverestTracker\n</code></pre> <p>Adds a tracker to the optimizer or ensemble evaluator.</p> <p>Trackers monitor the progress of the optimization or evaluation and record relevant results. They provide a way to capture and analyze the outcomes of during the execution of the workflow. You can configure a tracker to save the best or the last results generated.</p> <p>Invoking this method returns an <code>EverestTracker</code> object, which provides various methods to access the tracked results.</p> <p>A tracker is configured by the following arguments:</p> <p>what: This argument determines which results the tracker should record. You can choose from the following options:</p> <ul> <li><code>\"best\"</code>: Only the best result found so far is tracked.</li> <li><code>\"last\"</code>: Only the most recently generated result is tracked.</li> </ul> <p>The default value is <code>\"best\"</code>.</p> <p>constraint_tolerance: This optional argument specifies the tolerance for constraint satisfaction. It is used to determine whether a result is considered feasible, meaning it satisfies the defined constraints within the specified tolerance. Only feasible results will be recorded. If it is not set, constraints are not tested.</p> <p>Parameters:</p> Name Type Description Default <code>what</code> <code>Literal['best', 'last']</code> <p>Which results to track (\"best\" or \"last\").</p> <code>'best'</code> <code>constraint_tolerance</code> <code>float | None</code> <p>Tolerance for constraint satisfaction.</p> <code>None</code> <p>Returns:</p> Type Description <code>EverestTracker</code> <p>An <code>EverestTracker</code> object.</p>"},{"location":"reference/reference/#ropt_everest.HandlerMixin.add_store","title":"add_store","text":"<pre><code>add_store() -&gt; EverestStore\n</code></pre> <p>Adds a results store to the optimizer or ensemble evaluator.</p> <p>Stores the results of the optimization or evaluation.</p> <p>Invoking this method returns an <code>EverestStore</code> object, which provides various methods to access the stored results.</p> <p>Returns:</p> Type Description <code>EverestStore</code> <p>An <code>EverestStore</code> object.</p>"},{"location":"reference/reference/#ropt_everest.HandlerMixin.add_table","title":"add_table","text":"<pre><code>add_table(\n    table: EventHandler | None = None,\n) -&gt; EventHandler\n</code></pre> <p>Adds an event handler that creates a table with results on disk.</p> <p>This event handler will monitor the progress of the optimization or evaluation and record relevant results. A set of tables will then be generated and saved in the output directory.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>EventHandler | None</code> <p>Optional existing table to add, if <code>None</code> a new table is created.</p> <code>None</code> Note <p>This requires that the <code>everest-table</code> plugin for <code>ropt</code> is installed. If it is not installed, this method will do nothing and return <code>None</code>. In this case, no tables will be generated.</p> <p>Returns:</p> Type Description <code>EventHandler</code> <p>An <code>EverestTableHandler</code> object.</p>"},{"location":"reference/reference/#ropt_everest.EverestTracker","title":"ropt_everest.EverestTracker","text":"<p>               Bases: <code>DefaultTrackerHandler</code></p> <p>Provides access to the results generated by optimizers and evaluators.</p> <p>This class provides methods to retrieve and analyze the results tracked by a tracker within an Everest workflow. It allows you to access the results. You can also convert the tracked results into a Pandas DataFrame for easier analysis.</p> <p>The tracker can keep track of the best, the last, or all the results. The tracker can also be set to only keep track of the feasible results.</p>"},{"location":"reference/reference/#ropt_everest.EverestTracker.results","title":"results  <code>property</code>","text":"<pre><code>results: FunctionResults | None\n</code></pre> <p>Retrieves the tracked results.</p> <p>Returns:</p> Type Description <code>FunctionResults | None</code> <p>The tracked results.</p>"},{"location":"reference/reference/#ropt_everest.EverestTracker.controls","title":"controls  <code>property</code>","text":"<pre><code>controls: NDArray[float64] | None\n</code></pre> <p>Retrieves the tracked controls.</p> <p>Returns:</p> Type Description <code>NDArray[float64] | None</code> <p>The tracked controls.</p>"},{"location":"reference/reference/#ropt_everest.EverestTracker.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset the tracker.</p> <p>Clears any results accumulated so far.</p>"},{"location":"reference/reference/#ropt_everest.EverestTracker.dataframe","title":"dataframe","text":"<pre><code>dataframe(kind: str) -&gt; pd.DataFrame | None\n</code></pre> <p>Converts the tracked results to a Pandas DataFrame.</p> <p>This method converts the tracked results into a Pandas DataFrame, making it easier to analyze and visualize the data.</p> <p>The <code>kind</code> argument supports the following options:</p> <ul> <li><code>\"results\"</code>:       For function results.</li> <li><code>\"gradients\"</code>:     For gradient results.</li> <li><code>\"simulations\"</code>:   For simulation results.</li> <li><code>\"perturbations\"</code>: For perturbation results.</li> <li><code>\"constraints\"</code>:   For constraint information.</li> </ul> Note <p>The column names of the dataframe may be strings or tuples of strings. In the tuple form, the name is usually composed of a string indicating the type of column and one or more objective, constraint or control names. For instance, a column containing values of the control <code>point.x</code> may have the name: <code>(controls, point.x)</code>. The gradient of an objective <code>distance</code> with respect to a control <code>point.x</code> may have the column name <code>(objectives, distance, point.x.0)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>str</code> <p>The type of table to create.</p> required <p>Returns:</p> Type Description <code>DataFrame | None</code> <p>A Pandas DataFrame containing the tracked results, or None.</p>"},{"location":"reference/reference/#ropt_everest.EverestStore","title":"ropt_everest.EverestStore","text":"<p>               Bases: <code>DefaultStoreHandler</code></p> <p>Provides access to the results generated by optimizers and evaluators.</p> <p>This class provides methods to retrieve and analyze the results produced within an Everest workflow. It allows you to access the results. You can also convert the stored results into a Pandas DataFrame for easier analysis.</p>"},{"location":"reference/reference/#ropt_everest.EverestStore.results","title":"results  <code>property</code>","text":"<pre><code>results: list[Results] | None\n</code></pre> <p>Retrieves the stored results.</p> <p>Returns:</p> Type Description <code>list[Results] | None</code> <p>The stored results.</p>"},{"location":"reference/reference/#ropt_everest.EverestStore.controls","title":"controls  <code>property</code>","text":"<pre><code>controls: NDArray[float64] | list[NDArray[float64]] | None\n</code></pre> <p>Retrieves the stored controls.</p> <p>Returns:</p> Type Description <code>NDArray[float64] | list[NDArray[float64]] | None</code> <p>The stored controls.</p>"},{"location":"reference/reference/#ropt_everest.EverestStore.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset the store.</p> <p>Clears any results accumulated so far.</p>"},{"location":"reference/reference/#ropt_everest.EverestStore.dataframe","title":"dataframe","text":"<pre><code>dataframe(kind: str) -&gt; pd.DataFrame | None\n</code></pre> <p>Converts the stored results to a Pandas DataFrame.</p> <p>This method converts the tracked results into a Pandas DataFrame, making it easier to analyze and visualize the data.</p> <p>The <code>kind</code> argument supports the following options:</p> <ul> <li><code>\"results\"</code>:       For function results.</li> <li><code>\"gradients\"</code>:     For gradient results.</li> <li><code>\"simulations\"</code>:   For simulation results.</li> <li><code>\"perturbations\"</code>: For perturbation results.</li> <li><code>\"constraints\"</code>:   For constraint information.</li> </ul> Note <p>The column names of the dataframe may be strings or tuples of strings. In the tuple form, the name is usually composed of a string indicating the type of column and one or more objective, constraint or control names. For instance, a column containing values of the control <code>point.x</code> may have the name: <code>(controls, point.x)</code>. The gradient of an objective <code>distance</code> with respect to a control <code>point.x</code> may have the column name <code>(objectives, distance, point.x.0)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>str</code> <p>The type of table to create.</p> required <p>Returns:</p> Type Description <code>DataFrame | None</code> <p>A Pandas DataFrame containing the store results, or None.</p>"},{"location":"usage/basics/","title":"Basic Usage","text":""},{"location":"usage/basics/#running-custom-optimization-workflows","title":"Running custom optimization workflows","text":"<p>The ropt-everest plugin allows you to customize and extend the default optimization workflow in Everest. Normally, Everest performs a single optimization run based on the parameters in a YAML configuration file. However, with ropt-everest, you can override this behavior.</p> <p>To customize the workflow, create a Python file that contains a function named <code>run</code> with the following signature:</p> <pre><code>def run(evaluator: Evaluator) -&gt; None:\n    ...\n</code></pre> <p>The only argument is an <code>Evaluator</code> object. This object is created by Everest and provided to <code>run</code> via the <code>evaluator</code> parameter. This object will be passed to optimizers and ensemble evaluators to perform the black-box functions that they require. </p> <p>Everest can now directed to use the <code>run</code> function to run the workflow by setting the <code>ROPT_SCRIPT</code> environment variable. For instance:</p> <pre><code>ROPT_SCRIPT=run.py everest run config.yml\n</code></pre> <p>Developing and executing a custom workflow involves two key aspects:</p> <ol> <li> <p>Defining the workflow: This entails adding the individual steps and     their associated event handlers to the workflow. These steps can include     optimizers, evaluators, and other custom operations. Result handlers, such     as trackers and table outputs, capture the outcomes of each step.</p> </li> <li> <p>Executing and inspecting: This process involves arranging the defined     steps in the desired order of execution and leveraging the event handlers to     analyze the output data. Because the <code>run</code> function is implemented in     standard Python, you can use the full power of Python programming (e.g.,     loops, conditional statements, and custom functions) to create sophisticated     and adaptable optimization workflows.</p> </li> </ol> <p>A <code>run</code> function constructs a workflow by creating objects that execute the computations, such as optimizers and ensemble evaluators, with associated handler objects. You create these objects by calling factory functions such as <code>create_optimizer</code>. You then add event handlers to the new object using methods, such as for instance <code>add_tracker</code>. The created objects can then be executed by calling their <code>run</code> method.</p> <p>The <code>run</code> method may accept additional arguments to customize behavior. While executing, these objects may generate results. These are forwarded to any event handler objects that have been added to the object doing the computation. Handlers may also accept additional configuration arguments during creation to refine how they process these results.</p> <p>In summary, building an optimization workflow involves: 1) defining one or more objects that implement the computation, such as an optimization, 2) adding event handlers to these objects to process the results of those steps, and 3) finally, executing the steps by calling their <code>run</code> methods, potentially multiple times.</p> <p>For example, given athe Everest configuration file called <code>config.yml</code>, this script runs a single optimization and prints the best result it finds:</p> <pre><code>from ropt_everest import create_optimizer, load_config, run_everest\n\ndef run(evaluator):\n    config = load_config(\"config_example.yml\") # Load the configuration\n    optimizer = create_optimizer(evaluator)    # Create an optimizer\n    tracker = optimizer.add_tracker()          # Add a tracker\n    optimizer.run(config)                      # Run the optimizer\n    print(tracker.controls)                    # Print the best results\n</code></pre> <p>This function executes a basic optimization workflow by performing these steps:</p> <ol> <li>Load the configuration: Load an Everest configuration using the     <code>load_config</code> function.</li> <li>Create an optimizer: An optimizer step is added to the plan using the     <code>create_optimizer</code> function.</li> <li>Add a tracker: A tracker event handler is added to the optimizer using     the <code>add_tracker</code> method. This will     save the best results encountered during optimization.</li> <li>Execute the optimizer: The optimization process is started by calling     the <code>run</code> method of the optimizer. It     uses the configuration that was passed to Everest without modification.</li> <li>Print the result: The tracker has inspected all results and kept the best.     The best control values are displayed by printing the <code>controls</code> property of     the </li> </ol>"},{"location":"usage/basics/#classes-and-functions","title":"Classes and functions","text":"<p>The classes and functions of <code>ropt-everest</code> provide a high-level interface for defining and managing optimization workflows in Everest. It allows you to add various steps to the plan, such as optimizers, and evaluators, that are then executed to achieve the desired optimization goal.</p> <p>The <code>ropt-everest</code> package provides the following helper functions that create the objects for optimizers and ensemble evaluators:</p>"},{"location":"usage/basics/#create_optimizer","title":"<code>create_optimizer</code>","text":"<p>Creates an optimizer <code>EverestOptimizer</code> object that can be executed using its <code>run</code> method. The <code>run</code> method supports the following parameters to customize its behavior:</p> <ul> <li>config (<code>dict</code>, optional): An Everest configuration dictionary. You can     use the <code>load_config</code> function to load an Everest YAML     configuration file and parse it into a suitable dictionary.</li> <li>controls (<code>array-like</code>, optional): Initial control values for the     optimizer. If not specified, the initial values from the Everest     configuration are used.</li> <li>metadata (<code>dict</code>, optional): A dictionary of metadata to be associated     with each result generated by the optimizer.</li> <li>output_dir (<code>string</code>, optional): A directory (absolute or relative) where     the optimizer stores output. This is  useful when multiple optimization     runs are performed to prevent output from being overwritten.</li> </ul>"},{"location":"usage/basics/#create_ensemble_evaluator","title":"<code>create_ensemble_evaluator</code>","text":"<p>Adds an ensemble evaluator step to the workflow plan. The resulting <code>EverestEnsembleEvaluator</code> object can be executed using its <code>run</code> method. The <code>run</code> method supports the following parameters to customize its behavior:</p> <ul> <li>config (<code>dict</code>, optional): An Everest configuration dictionary. You can     use the <code>load_config</code> function to load an Everest YAML     configuration file and parse it into a suitable dictionary.</li> <li>controls (<code>array-like</code>, optional): The controls that will be evaluated.     This can be a single vector, a sequence of multiple vectors, or a 2D matrix     where the control vectors are the rows. If multiple vectors or a 2D matrix     is supplied, an evaluation is performed for each control vector. If not     specified, the initial values from the Everest configuration are used.</li> <li>metadata (<code>dict</code>, optional): A dictionary of metadata to be associated     with each result generated by the evaluator.</li> <li>output_dir (<code>string</code>, optional): A directory (absolute or relative) where     the ensemble evaluator stores output. This is  useful when multiple     runs are performed to prevent output from bing overwritten.</li> </ul> <p>The optimizers end ensemble evaluators created by these function are executed by their <code>run</code> methods. While executing they emit events that can be handled by event handler objects that are added by the following methods:</p>"},{"location":"usage/basics/#add_tracker","title":"<code>add_tracker</code>","text":"<p>Adds a result tracker to the optimizer or ensemble evaluator to monitor the progress. The resulting <code>EverestTracker</code> object tracks and stores emitted results. It accepts the following arguments:</p> <ul> <li>what: This argument determines which results the tracker should     record. Possible values:<ul> <li><code>\"best\"</code>: Only the best result found so far is tracked. This is the default.</li> <li><code>\"last\"</code>: Only the most recently generated result is tracked.</li> </ul> </li> <li>constraint_tolerance: A tolerance for detecting constraint violations.</li> </ul> <p>The tracker object returned by <code>add_tracker</code> method supports the following properties to inspect the results that it stores:</p> <ul> <li><code>results</code>:  The results object that   is stored.</li> <li><code>controls</code>: The controls in the   stored results.</li> </ul> <p>In addition, the following methods are available:</p> <ul> <li><code>reset</code>: Reset the tracker to contain     no results.</li> <li><code>dataframe</code>: Export the results     as Pandas data frames.</li> </ul>"},{"location":"usage/basics/#add_store","title":"<code>add_store</code>","text":"<p>Adds a result store to the optimizer or ensemble evaluator to record the progress of a step. The resulting <code>EverestStore</code> object stores results emitted by optimizers and evaluators that it is monitoring.</p> <p>The store object returned by <code>add_store</code> supports the following properties to inspect the results that it stores:</p> <ul> <li><code>results</code>:  The list of results that   is stored.</li> <li><code>controls</code>: The controls in the   stored results.</li> </ul> <p>In addition, the following methods are available:</p> <ul> <li><code>reset</code>: Reset the tracker to contain     no results.</li> <li><code>dataframe</code>: Export the results     as Pandas data frames.</li> </ul>"},{"location":"usage/basics/#add_table","title":"<code>add_table</code>","text":"<p>Adds a table event handler to the plan. This handler writes text files summarizing the results to the output directory.</p>"},{"location":"usage/everest_config/","title":"Everest configuration","text":""},{"location":"usage/everest_config/#modifying-everest-configuration-settings","title":"Modifying Everest Configuration Settings","text":"<p>Within the <code>run</code> function you will usually load an Everest configuration using the <code>load_config</code> function. This configuration can be modified before running any optimization or evaluation steps. However, it's important to note that not all modifications will necessarily take effect, and some may lead to unexpected behavior. Currently, it's considered safe to modify most settings within the <code>optimization</code> section, as well as the <code>realization_weights</code> in the <code>model</code> section.</p>"},{"location":"usage/everest_config/#handling-max_batch_num","title":"Handling <code>max_batch_num</code>","text":"<p>Modifying the <code>max_batch_num</code> setting within the <code>optimization</code> section after the plan has started will have no effect. It's crucial to understand that <code>max_batch_num</code> determines the total number of batches allowed across the entire optimization process. Consequently, if your <code>run</code> function includes multiple optimization runs, and the first run reaches the <code>max_batch_num</code> limit, subsequent optimization steps will not be executed.</p>"},{"location":"usage/examples/","title":"Examples","text":"<p>It is recommended to run these examples directly using this script template, so that output is printed to the console:</p> <pre><code>def run(evaluator):\n    ...\n\nif __name__ == \"__main__\":\n    import warnings\n\n    warnings.filterwarnings(\"ignore\")\n    run_everest(\"config_example.yml\", script=__file__)\n</code></pre>"},{"location":"usage/examples/#basic-plan","title":"Basic plan","text":"<p>A basic plan that corresponds to the default Everest optimization, while writing results to disk:</p> <pre><code>from ropt_everest import create_optimizer, load_config, run_everest\n\ndef run(evaluator):\n    config = load_config(\"config_example.yml\")\n    optimizer = create_optimizer(evaluator)\n    optimizer.add_table()\n    optimizer.run(config)\n</code></pre>"},{"location":"usage/examples/#running-two-optimizers","title":"Running two optimizers","text":"<p>Running two optimizers, sending optimizer output to different directories:</p> <pre><code>from ropt_everest import create_optimizer, load_config, run_everest\n\ndef run(evaluator):\n    config = load_config(\"config_example.yml\")\n    optimizer = create_optimizer(evaluator)\n    tracker = optimizer.add_tracker(what=\"last\")\n    store = optimizer.add_store()\n    optimizer.add_table()\n\n    for idx in range(3):\n        optimizer.run(\n            config,\n            controls=tracker.controls,\n            metadata={\"iteration\": idx},\n            output_dir=f\"output{idx}\",\n        )\n    print(store.dataframe(\"simulations\"))\n</code></pre>"},{"location":"usage/examples/#running-optimizers-in-a-loop","title":"Running optimizers in a loop","text":"<p>Run an optimizer in a loop, each time starting from the last result of the previous. Store all results in memory and export the simulations of all to a Pandas data frame. In addition, add the index of the loop to the metadata, which an additional <code>iteration</code> column to the data frame:</p> <pre><code>from ropt_everest import create_optimizer, load_config, run_everest\n\n\ndef run(evaluator):\n    config = load_config(\"config_example.yml\")\n    optimizer = create_optimizer(evaluator)\n    tracker = optimizer.add_tracker(what=\"last\")\n    store = optimizer.add_store()\n    optimizer.add_table()\n\n    for idx in range(3):\n        optimizer.run(\n            config,\n            controls=tracker.controls,\n            metadata={\"iteration\": idx},\n            output_dir=f\"output{idx}\",\n        )\n    print(store.dataframe(\"simulations\"))\n</code></pre>"},{"location":"usage/examples/#running-an-evaluation","title":"Running an evaluation","text":"<p>Run an evaluation of the function for two control vectors and export the results to a Pandas data frame:</p> <pre><code>from ropt_everest import create_ensemble_evaluator, load_config, run_everest\n\ndef run(evaluator):\n    config = load_config(\"config_example.yml\")\n    evaluator = create_ensemble_evaluator(evaluator)\n    store = evaluator.add_store()\n    evaluator.run(config, controls=[[0, 0, 0], [0.25, 0.25, 0.25], [1, 1, 1]])\n    print(store.dataframe(\"results\"))\n</code></pre>"},{"location":"usage/running/","title":"Running the workflow","text":"<p>Typically, Everest optimization workflows are executed using the standard Everest command-line interface (CLI). This approach works seamlessly even when you've implemented a custom <code>run</code> function using <code>ropt-everest</code>. However, the Everest CLI often obscures exceptions and errors, providing limited feedback or relegating detailed information to log files. This can be cumbersome during the development of a custom <code>run</code> function, as not all exceptions are immediately visible. Moreover, the standard Everest CLI redirects standard output (stdout) and standard error (stderr) to files, which can further complicate debugging.</p> <p>To address these challenges, <code>ropt-everest</code> offers the <code>run_everest</code> function. This function allows you to execute an Everest optimization directly, bypassing the Everest CLI. Instead of launching a separate server process in the background or on a cluster, as the Everest CLI typically does, the <code>run_everest</code> method runs the optimization directly within your current process. A key benefit of this is that anything written to <code>stdout</code> or <code>stderr</code> is sent directly to your console.</p> <p>In the simplest case, <code>run_everest</code> takes only the name of the Everest configuration file, and runs the default optimization workflow. To run a custom workflow, the <code>script</code> keyword argument can be set to the name of Python script that provides a <code>run</code> function that executes the custom plan.</p> <p>Example: Custom <code>run</code> and Direct Execution</p> <p>Here's an example of a Python script that customizes the optimization process. It can be run using Everest by setting the <code>ROPT_SCRIPT</code> variable to the name of this script. However, it can also be directly executed as a Python script, using the <code>run_everest</code> function:</p> <pre><code>from ropt_everest import create_optimizer, load_config, run_everest\n\ndef run(evaluator):\n    config = load_config(\"config_example.yml\")\n    optimizer = create_optimizer(evaluator)\n    tracker = optimizer.add_tracker()\n    optimizer.run(config)\n    print(tracker.controls)\n\nif __name__ == \"__main__\":\n    import warnings\n\n    warnings.filterwarnings(\"ignore\")\n    run_everest(\"config_example.yml\", script=__file__)\n</code></pre> <p>Here, within the <code>if __name__ == \"__main__\":</code> block, we first suppress warnings that Everest might produce. These warnings are generally intended for end-users and are typically not relevant during the development of a custom <code>run</code> function. We then execute the <code>run_everest</code> function, passing the path to the configuration file and to the script file.</p> <p>Note: Running on a HPC cluster</p> <p>The standard Everest command interface runs the optimization as a separate server process. If Everest is configured for an HPC cluster, this server process, which manages the optimization, is submitted to and executes on the cluster.</p> <p>In contrast, the direct execution method (<code>run_everest</code>) runs the optimization within the current Python process. Consequently, the optimization executes on the machine where your script is run (e.g., a login node or your local machine), not automatically on an HPC cluster compute node. This is true even if Everest is configured to use the cluster for other tasks, such as forward model evaluations.</p> <p>Importantly, regardless of how the optimization process itself is launched (standard CLI or direct execution), forward model evaluations managed by Everest will still be submitted to the HPC cluster if Everest is configured to do so.</p> <p>If you intend for the main optimization process (when using direct execution via <code>run_everest</code>) to also run on an HPC cluster, you must explicitly submit your Python script to the cluster. This is done using standard cluster job submission procedures, such as creating a batch script for schedulers like SLURM or PBS.</p>"}]}