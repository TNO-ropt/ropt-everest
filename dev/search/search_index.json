{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>ropt-everest</code>","text":"<p>The <code>ropt-everest</code> plugin extends <code>ropt</code> with functionality specific to Everest. It primarily offers two key features:</p> <ol> <li>Enhanced Reporting: It generates tables containing optimization results,    which are saved to disk after each batch evaluation.</li> <li>Custom Workflow Implementation: It provides the ability to load custom    Python code to override the default optimization workflow.</li> </ol>"},{"location":"reference/everest_plan/","title":"Everest Plan","text":""},{"location":"reference/everest_plan/#ropt_everest.EverestPlan","title":"ropt_everest.EverestPlan","text":"<p>Represents an execution plan for an Everest optimization workflow.</p> <p>The <code>EverestPlan</code> class provides a high-level interface for defining and managing optimization workflows in Everest. It allows you to add various steps to the plan, such as optimizers and evaluators, that are then executed to achieve the desired optimization goal.</p>"},{"location":"reference/everest_plan/#ropt_everest.EverestPlan.add_optimizer","title":"add_optimizer","text":"<pre><code>add_optimizer() -&gt; EverestOptimizerStep\n</code></pre> <p>Adds an optimizer to the execution plan.</p> <p>This method integrates an optimization step into your Everest workflow. Invoking this method returns an <code>EverestOptimizerStep</code> object, which you can execute using its <code>run</code> method.</p> <p>Returns:</p> Type Description <code>EverestOptimizerStep</code> <p>An <code>EverestOptimizerStep</code> object, representing the added optimizer.</p>"},{"location":"reference/everest_plan/#ropt_everest.EverestPlan.add_ensemble_evaluator","title":"add_ensemble_evaluator","text":"<pre><code>add_ensemble_evaluator() -&gt; EverestEnsembleEvaluatorStep\n</code></pre> <p>Adds an evaluator to the execution plan.</p> <p>This method integrates an ensemble evaluator step into your Everest workflow. Invoking this method returns an <code>EverestEnsembleEvaluatorStep</code> object, which you can execute using its <code>run</code> method.</p> <p>Returns:</p> Type Description <code>EverestEnsembleEvaluatorStep</code> <p>An <code>EverestEnsembleEvaluatorStep</code> object, representing the added evaluator.</p>"},{"location":"reference/everest_plan/#ropt_everest.EverestPlan.add_cache","title":"add_cache","text":"<pre><code>add_cache(\n    steps: EverestStepBase\n    | Sequence[EverestStepBase]\n    | set[EverestStepBase],\n    sources: EverestEventHandlerBase\n    | Sequence[EverestEventHandlerBase]\n    | set[EverestEventHandlerBase],\n) -&gt; EverestCachedEvaluator\n</code></pre> <p>Adds an cache to the execution plan.</p> <p>This method integrates a caching mechanism into your Everest workflow. Invoking this method returns an <code>EverestCachedEvaluator</code> object, which will act as a cache.</p> <p>The cache is only serving the steps specified in the <code>steps</code> argument. Cached values are retrieved from the specified source(s) and used to avoid redundant evaluations. The sources must be an event handler that stores the results produced by the optimization or evaluation steps.</p> <p>Parameters:</p> Name Type Description Default <code>steps</code> <code>EverestStepBase | Sequence[EverestStepBase] | set[EverestStepBase]</code> <p>The steps that will use the cache.</p> required <code>sources</code> <code>EverestEventHandlerBase | Sequence[EverestEventHandlerBase] | set[EverestEventHandlerBase]</code> <p>The source(s) of cached values.</p> required <p>Returns:</p> Type Description <code>EverestCachedEvaluator</code> <p>A cache object.</p>"},{"location":"reference/everest_plan/#ropt_everest.EverestPlan.add_store","title":"add_store","text":"<pre><code>add_store(\n    steps: EverestStepBase | Sequence[EverestStepBase],\n) -&gt; EverestStore\n</code></pre> <p>Adds a results store to the execution plan.</p> <p>Stores the results of specified optimization or evaluation steps.</p> <p>Invoking this method returns an <code>EverestStore</code> object, which provides various methods to access the stored results.</p> <p>steps: This argument specifies which steps in the execution plan the store should monitor. You can provide either a single step object (such as an optimizer or evaluator) or a sequence of steps. The store object will record all the results generated by these steps.</p> <p>Parameters:</p> Name Type Description Default <code>steps</code> <code>EverestStepBase | Sequence[EverestStepBase]</code> <p>The EverestStep(s) to monitor.</p> required <p>Returns:</p> Type Description <code>EverestStore</code> <p>An <code>EverestStore</code> object, which can be used to access the stored results.</p>"},{"location":"reference/everest_plan/#ropt_everest.EverestPlan.add_tracker","title":"add_tracker","text":"<pre><code>add_tracker(\n    steps: EverestStepBase | Sequence[EverestStepBase],\n    *,\n    what: Literal[\"best\", \"last\"] = \"best\",\n    constraint_tolerance: float | None = None,\n) -&gt; EverestTracker\n</code></pre> <p>Adds a tracker to the execution plan.</p> <p>Trackers monitor the progress of specified optimization or evaluation steps and record relevant results. They provide a way to capture and analyze the outcomes of these steps during the execution of the plan. You can configure a tracker to save the best or the last results generated by the tracked steps.</p> <p>Invoking this method returns an <code>EverestTracker</code> object, which provides various methods to access the tracked results.</p> <p>A tracker is configured by three arguments:</p> <p>steps: This argument specifies which steps in the execution plan the tracker should monitor. You can provide either a single step object (such as an optimizer or evaluator) or a sequence of steps. The tracker will record the results generated by these steps.</p> <p>what: This argument determines which results the tracker should record. You can choose from the following options:</p> <ul> <li><code>\"best\"</code>: Only the best result found so far is tracked.</li> <li><code>\"last\"</code>: Only the most recently generated result is tracked.</li> </ul> <p>The default value is <code>\"best\"</code>.</p> <p>constraint_tolerance: This optional argument specifies the tolerance for constraint satisfaction. It is used to determine whether a result is considered feasible, meaning it satisfies the defined constraints within the specified tolerance. Only feasible results will be recorded. If it is not set, constraints are not tested.</p> <p>Parameters:</p> Name Type Description Default <code>steps</code> <code>EverestStepBase | Sequence[EverestStepBase]</code> <p>The EverestStep(s) to monitor.</p> required <code>what</code> <code>Literal['best', 'last']</code> <p>Which results to track (\"best\" or \"last\").</p> <code>'best'</code> <code>constraint_tolerance</code> <code>float | None</code> <p>Tolerance for constraint satisfaction.</p> <code>None</code> <p>Returns:</p> Type Description <code>EverestTracker</code> <p>An <code>EverestTracker</code> object, which can be used to access the tracked results.</p>"},{"location":"reference/everest_plan/#ropt_everest.EverestPlan.add_table","title":"add_table","text":"<pre><code>add_table(\n    steps: EverestStepBase | Sequence[EverestStepBase],\n) -&gt; EverestTableHandler\n</code></pre> <p>Adds an event handler that create a table to the execution plan.</p> <p>This event handler will monitor the progress of specified optimization or evaluation steps and record relevant results. A set of tables will then be generated and saved in the output directory.</p> <p>Parameters:</p> Name Type Description Default <code>steps</code> <code>EverestStepBase | Sequence[EverestStepBase]</code> <p>The EverestStep(s) to monitor.</p> required <p>Returns:</p> Type Description <code>EverestTableHandler</code> <p>An <code>EverestTableHandler</code> object.</p>"},{"location":"reference/everest_plan/#ropt_everest.EverestOptimizerStep","title":"ropt_everest.EverestOptimizerStep","text":"<p>               Bases: <code>EverestStepBase</code></p> <p>Represents an optimizer step in an Everest execution plan.</p> <p>This class encapsulates an optimization step within an Everest workflow. It provides a method to execute the optimizer.</p>"},{"location":"reference/everest_plan/#ropt_everest.EverestOptimizerStep.run","title":"run","text":"<pre><code>run(\n    config: dict[str, Any],\n    controls: ArrayLike | None = None,\n    metadata: dict[str, Any] | None = None,\n    output_dir: str | None = None,\n) -&gt; None\n</code></pre> <p>Runs the optimizer.</p> <p>This method executes the underlying optimizer with the given parameters.</p> <p>Configuration:</p> <ul> <li>The <code>config</code> dictionary should be a dictionary that can be validated   as an <code>EverestConfig</code> object.</li> </ul> <p>Controls:</p> <p>If no controls are provided, the optimizer will use the initial values from the configuration.</p> <p>Metadata:</p> <ul> <li>The <code>metadata</code> parameter allows you to associate arbitrary data with   each result generated by the optimizer or ensemble evaluators.</li> <li>This metadata is included in generated tables and data frames.</li> <li>The keys in the <code>metadata</code> dictionary are used as column names in   the output tables.</li> </ul> <p>Optimizer output:</p> <p>Normally, the optimizer's output is directed to the <code>optimization_output</code> subdirectory within the main output directory specified in the Everest configuration. When multiple optimization steps are executed, there's a risk of output files being overwritten. The <code>output_dir</code> argument provides a way to override the default output location for the optimizer. You can specify an absolute path, or a relative path, which will be interpreted as relative to the <code>optimization_output</code> directory.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any]</code> <p>An optional dictionary containing the Everest configuration         for the optimizer. If omitted, the default configuration is         used.</p> required <code>controls</code> <code>ArrayLike | None</code> <p>An array-like object containing the controls for the optimization.</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>An optional dictionary of metadata to associate with the         results of the optimizer's results.</p> <code>None</code> <code>output_dir</code> <code>str | None</code> <p>An optional output directory for the optimizer.</p> <code>None</code>"},{"location":"reference/everest_plan/#ropt_everest.EverestEnsembleEvaluatorStep","title":"ropt_everest.EverestEnsembleEvaluatorStep","text":"<p>               Bases: <code>EverestStepBase</code></p> <p>Represents an evaluator step in an Everest execution plan.</p> <p>This class encapsulates an evaluation step within an Everest workflow. It provides a method to execute the evaluator .</p>"},{"location":"reference/everest_plan/#ropt_everest.EverestEnsembleEvaluatorStep.run","title":"run","text":"<pre><code>run(\n    config: dict[str, Any],\n    controls: ArrayLike | None = None,\n    metadata: dict[str, Any] | None = None,\n) -&gt; None\n</code></pre> <p>Runs the ensemble evaluator.</p> <p>This method executes the underlying ensemble evaluator with the given parameters.</p> <p>Configuration:</p> <ul> <li>The <code>config</code> dictionary should be a dictionary that can be validated   as an <code>EverestConfig</code> object.</li> </ul> <p>Controls:</p> <p>The <code>controls</code> parameter can be a single vector, a sequence of multiple vectors, or a 2D matrix where the control vectors are the rows. If no controls are provided, the evaluator will use its default the initial values from the configuration.</p> <p>Metadata:</p> <ul> <li>The <code>metadata</code> parameter allows you to associate arbitrary data with   each result generated by the optimizer or evaluators.</li> <li>This metadata is included in generated tables and data frames.</li> <li>The keys in the <code>metadata</code> dictionary are used as column names in   the output tables.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any]</code> <p>An optional dictionary containing the Everest configuration       for the optimizer. If omitted, the default configuration is       used.</p> required <code>controls</code> <code>ArrayLike | None</code> <p>An array-like object containing the controls for the optimization.</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>An optional dictionary of metadata to associate with the       results of the optimizer's results.</p> <code>None</code>"},{"location":"reference/everest_plan/#ropt_everest.EverestStore","title":"ropt_everest.EverestStore","text":"<p>               Bases: <code>EverestEventHandlerBase</code></p> <p>Provides access to the results stored by an Everest execution plan.</p> <p>This class provides methods to retrieve and analyze the results produces within an Everest execution plan. It allows you to access the results. You can also convert the stored results into a Pandas DataFrame for easier analysis.</p>"},{"location":"reference/everest_plan/#ropt_everest.EverestStore.results","title":"results  <code>property</code>","text":"<pre><code>results: list[Results] | None\n</code></pre> <p>Retrieves the stored results.</p> <p>Returns:</p> Type Description <code>list[Results] | None</code> <p>The stored results.</p>"},{"location":"reference/everest_plan/#ropt_everest.EverestStore.controls","title":"controls  <code>property</code>","text":"<pre><code>controls: NDArray[float64] | list[NDArray[float64]] | None\n</code></pre> <p>Retrieves the stored controls.</p> <p>Returns:</p> Type Description <code>NDArray[float64] | list[NDArray[float64]] | None</code> <p>The stored controls.</p>"},{"location":"reference/everest_plan/#ropt_everest.EverestStore.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset the store.</p> <p>Clears any results accumulated so far.</p>"},{"location":"reference/everest_plan/#ropt_everest.EverestStore.dataframe","title":"dataframe","text":"<pre><code>dataframe(kind: str) -&gt; pd.DataFrame | None\n</code></pre> <p>Converts the stored results to a Pandas DataFrame.</p> <p>This method converts the tracked results into a Pandas DataFrame, making it easier to analyze and visualize the data.</p> <p>The <code>kind</code> argument supports the following options:</p> <ul> <li><code>\"results\"</code>:       For function results.</li> <li><code>\"gradients\"</code>:     For gradient results.</li> <li><code>\"simulations\"</code>:   For simulation results.</li> <li><code>\"perturbations\"</code>: For perturbation results.</li> <li><code>\"constraints\"</code>:   For constraint information.</li> </ul> Note <p>The column names of the dataframe may be strings or tuples of strings. In the tuple form, the name is usually composed of a string indicating the type of column and one or more objective, constraint or control names. For instance, a column containing values of the control <code>point.x</code> may have the name: <code>(controls, point.x)</code>. The gradient of an objective <code>distance</code> with respect to a control <code>point.x</code> may have the column name <code>(objectives, distance, point.x.0)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>str</code> <p>The type of table to create.</p> required <p>Returns:</p> Type Description <code>DataFrame | None</code> <p>A Pandas DataFrame containing the store results, or None.</p>"},{"location":"reference/everest_plan/#ropt_everest.EverestTracker","title":"ropt_everest.EverestTracker","text":"<p>               Bases: <code>EverestEventHandlerBase</code></p> <p>Provides access to the results generated by an Everest execution plan.</p> <p>This class provides methods to retrieve and analyze the results tracked by a tracker within an Everest execution plan. It allows you to access the results. You can also convert the tracked results into a Pandas DataFrame for easier analysis.</p> <p>The tracker can keep track of the best, the last, or all the results. The tracker can also be set to only keep track of the feasible results.</p>"},{"location":"reference/everest_plan/#ropt_everest.EverestTracker.results","title":"results  <code>property</code>","text":"<pre><code>results: FunctionResults | None\n</code></pre> <p>Retrieves the tracked results.</p> <p>Returns:</p> Type Description <code>FunctionResults | None</code> <p>The tracked results.</p>"},{"location":"reference/everest_plan/#ropt_everest.EverestTracker.controls","title":"controls  <code>property</code>","text":"<pre><code>controls: NDArray[float64] | None\n</code></pre> <p>Retrieves the tracked controls.</p> <p>Returns:</p> Type Description <code>NDArray[float64] | None</code> <p>The tracked controls.</p>"},{"location":"reference/everest_plan/#ropt_everest.EverestTracker.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset the tracker.</p> <p>Clears any results accumulated so far.</p>"},{"location":"reference/everest_plan/#ropt_everest.EverestTracker.dataframe","title":"dataframe","text":"<pre><code>dataframe(kind: str) -&gt; pd.DataFrame | None\n</code></pre> <p>Converts the tracked results to a Pandas DataFrame.</p> <p>This method converts the tracked results into a Pandas DataFrame, making it easier to analyze and visualize the data.</p> <p>The <code>kind</code> argument supports the following options:</p> <ul> <li><code>\"results\"</code>:       For function results.</li> <li><code>\"gradients\"</code>:     For gradient results.</li> <li><code>\"simulations\"</code>:   For simulation results.</li> <li><code>\"perturbations\"</code>: For perturbation results.</li> <li><code>\"constraints\"</code>:   For constraint information.</li> </ul> Note <p>The column names of the dataframe may be strings or tuples of strings. In the tuple form, the name is usually composed of a string indicating the type of column and one or more objective, constraint or control names. For instance, a column containing values of the control <code>point.x</code> may have the name: <code>(controls, point.x)</code>. The gradient of an objective <code>distance</code> with respect to a control <code>point.x</code> may have the column name <code>(objectives, distance, point.x.0)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>str</code> <p>The type of table to create.</p> required <p>Returns:</p> Type Description <code>DataFrame | None</code> <p>A Pandas DataFrame containing the tracked results, or None.</p>"},{"location":"reference/everest_plan/#ropt_everest.EverestTableHandler","title":"ropt_everest.EverestTableHandler","text":"<p>               Bases: <code>EverestEventHandlerBase</code></p> <p>Represents a table event handler in an Everest execution plan.</p>"},{"location":"reference/everest_plan/#ropt_everest.EverestCachedEvaluator","title":"ropt_everest.EverestCachedEvaluator","text":"<p>               Bases: <code>EverestEvaluatorBase</code></p>"},{"location":"reference/everest_plan/#ropt_everest.load_config","title":"ropt_everest.load_config","text":"<pre><code>load_config(config_file: str) -&gt; dict[str, Any]\n</code></pre> <p>Loads an Everest configuration from a YAML file.</p> <p>This function reads an Everest configuration specified by the <code>config_file</code> path, parses it, and returns it as a Python dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>The path to the Everest configuration YAML file.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representing the Everest configuration.</p>"},{"location":"reference/everest_plan/#ropt_everest.run_everest","title":"ropt_everest.run_everest","text":"<pre><code>run_everest(\n    config_file: str,\n    *,\n    script: str | None = None,\n    report_exit_code: bool = True,\n) -&gt; EverestExitCode\n</code></pre> <p>Runs an Everest optimization directly from a configuration file.</p> <p>This function provides a convenient way to execute an Everest optimization plan  without having to use the <code>everest</code> command. This method will run a full optimization, but it will not produce the usual monitoring output of Everest.</p> <p>Using this method instead of the <code>everest</code> command-line tool offers several advantages, including:</p> <ul> <li>Direct access to standard output (stdout): Unlike the <code>everest</code>     command, this does not redirect standard output.</li> <li>Error traces: If errors occur during the optimization, you'll get a     full Python stack trace, making debugging easier.</li> <li>Exceptional exit conditions, such as maximum number batch reached, or     a user abort are reported, if <code>report_exit_code</code> is set.</li> </ul> <p>The optional <code>script</code> argument is used to define a custom script that runs the optimization. If it is <code>None</code>, a script name is constructed from the <code>config_file</code> argument by replacing the <code>.yml</code> extension with <code>.py</code>. If the file named by <code>script</code> does not exists, the argument is ignored and the default optimization workflow is run.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>The path to the Everest configuration file (YAML).</p> required <code>script</code> <code>str | None</code> <p>Optional script to replace the default optimization.</p> <code>None</code> <code>report_exit_code</code> <code>bool</code> <p>If <code>True</code>, report the exit code.</p> <code>True</code> <p>Returns:</p> Type Description <code>EverestExitCode</code> <p>The Everest exit code.</p>"},{"location":"usage/basics/","title":"Basic Usage","text":""},{"location":"usage/basics/#running-custom-optimization-workflows","title":"Running custom optimization workflows","text":"<p>The ropt-everest plugin allows you to customize and extend the default optimization workflow in Everest. Normally, Everest performs a single optimization run based on the parameters in a YAML configuration file. However, with ropt-everest, you can override this behavior.</p> <p>To customize the workflow, create a Python file that contains a function named <code>run_plan</code> with the following signature:</p> <pre><code>def run_plan(plan: EverestPlan) -&gt; None:\n    ...\n</code></pre> <p>The only argument is an <code>EverestPlan</code> object, which is used to define and execute the optimization workflow. This object is created by Everest and provided to <code>run_plan</code> via the <code>plan</code> parameter. </p> <p>Everest can now directed to use this function to run the optimization by setting the <code>ROPT_SCRIPT</code> environment variable. For instance:</p> <pre><code>ROPT_SCRIPT=config.py everest run config.py\n</code></pre> <p>This might be useful if you prefer to name your script differently from the, or keep it in different location.</p> <p>Developing and executing a custom workflow involves two key aspects:</p> <ol> <li> <p>Defining the Workflow: This entails adding the individual steps and     their associated event handlers to the <code>EverestPlan</code>. These steps can     include optimizers, evaluators, and other custom operations. Result     handlers, such as trackers and table outputs, capture the outcomes of each     step.</p> </li> <li> <p>Executing and Inspecting: This process involves arranging the defined     steps in the desired order of execution and leveraging the event handlers     to analyze the output data. The <code>EverestPlan</code> automatically manages the     execution of these steps, guaranteeing their correct operation and ensuring     that results are consistently captured and made accessible. Because the     <code>run_plan</code> function is implemented in standard Python, you can use the full     power of Python programming (e.g., loops, conditional statements, and custom     functions) to create sophisticated and adaptable optimization workflows.</p> </li> </ol> <p>A <code>run_plan</code> function constructs a workflow by creating step objects and handler objects. You create these objects by calling methods on the <code>plan</code> object, typically using the pattern <code>plan.add_*()</code>. For example, <code>plan.add_optimizer()</code> creates an optimizer step and registers it with the plan. When added to the plan, step objects generally don't require arguments. Instead, you configure and execute them later by calling their <code>run</code> method (e.g., to start an optimization).</p> <p>The <code>run</code> method may accept additional arguments to customize the step's behavior. As steps execute, they may generate results. The plan receives these results and forwards them to any event handler objects that have expressed interest. When creating event handler objects, you specify one or more step objects they should monitor, indicating their interest in receiving results from those steps. Handlers may also accept additional configuration arguments during creation to refine how they process these results.</p> <p>In summary, building an optimization workflow involves: 1) defining one or more steps, 2) adding event handlers to process the results of those steps, and 3) finally, executing the steps by calling their <code>run</code> methods, potentially multiple times.</p> <p>For example, this <code>run_plan</code> function reproduces the default Everest optimization, assuming the Everest configuration file is called <code>config.yml</code>:</p> <pre><code>def run_plan(plan):\n    config = load_config(\"config.yml\")  # Load the configuration\n    optimizer = plan.add_optimizer()    # Add an optimizer step\n    plan.add_table(optimizer)           # Add a table event handler\n    optimizer.run(config)               # Run the optimizer\n</code></pre> <p>This function executes a basic optimization workflow by performing these steps:</p> <ol> <li>Loading Configuration: Load an Everest configuration using the     <code>load_config</code> function.</li> <li>Plan Creation: Everest creates an     <code>EverestPlan</code> object and passes it to <code>run_plan</code>     via the <code>plan</code> parameter. In addition it passes the Everest configuration     dictionary, although it is not used in this example.</li> <li>Optimizer Addition: An optimizer step is added to the plan using the     <code>add_optimizer</code> method.</li> <li>Table Handler Addition: A table event handler is added to the plan using     the <code>add_table</code> method. This will save     the optimization results in a set of tables.</li> <li>Optimizer Execution: The optimization process is started by calling the     <code>run</code> method of the optimizer step. It     uses the configuration that was passed to Everest without modification.</li> </ol>"},{"location":"usage/basics/#everestplan-methods","title":"EverestPlan Methods","text":"<p>The <code>EverestPlan</code> class provides a high-level interface for defining and managing optimization workflows in Everest. It allows you to add various steps to the plan, such as optimizers, and evaluators, that are then executed to achieve the desired optimization goal.</p> <p>Key Features:</p> <ul> <li>Step Management: Add and manage different types of optimization steps,     including optimizers, and evaluators.</li> <li>Tracking and Monitoring: Incorporate trackers to monitor the progress of     specific steps and collect relevant results.</li> <li>Table Generation: Generate tables to summarize the results of the     optimization process.</li> <li>Configuration Handling: Manage Everest configurations, including the     ability to override default settings.</li> <li>Metadata Association: Associate arbitrary metadata with steps and results,    facilitating the tracking of additional information.</li> <li>Direct Execution: Execute the plan directly, providing more control over     stdout and error traces.</li> <li>Caching Results: Add cache objects to the plan that use the results in     handlers defined in the plan. Any results stored by those handlers can be     re-used by the optimizer and evaluation steps.</li> </ul> <p>The <code>EverestPlan</code> object provides several methods for building and managing optimization workflows:</p>"},{"location":"usage/basics/#add_optimizer","title":"<code>add_optimizer</code>","text":"<p>Adds an optimizer step to the workflow plan. The resulting <code>EverestOptimizerStep</code> object can be executed using its <code>run</code> method. The <code>run</code> method supports the following parameters to customize its behavior:</p> <ul> <li>config (<code>dict</code>, optional): An Everest configuration dictionary. You can     copy and modify the configuration passed to the <code>run_plan</code> function to     create a suitable configuration, or you can construct or load your own.</li> <li>controls (<code>array-like</code>, optional): Initial control values for the     optimizer. If not specified, the initial values from the Everest     configuration are used.</li> <li>metadata (<code>dict</code>, optional): A dictionary of metadata to be associated     with each result generated by the optimizer.</li> <li>output_dir (<code>string</code>, optional): A directory (absolute or relative) where     the optimizer stores output. This is  useful when multiple optimization     runs are performed to prevent output from bing overwritten.</li> </ul>"},{"location":"usage/basics/#add_ensemble_evaluator","title":"<code>add_ensemble_evaluator</code>","text":"<p>Adds an ensemble evaluator step to the workflow plan. The resulting <code>EverestEnsembleEvaluatorStep</code> object can be executed using its <code>run</code> method. The <code>run</code> method supports the following parameters to customize its behavior:</p> <ul> <li>config (<code>dict</code>, optional): An Everest configuration dictionary. You can     copy and modify the configuration passed to the <code>run_plan</code> function to     create a suitable configuration, or you can construct or load your own.</li> <li>controls (<code>array-like</code>, optional): The controls that will be evaluated.     This can be a single vector, a sequence of multiple vectors, or a 2D matrix     where the control vectors are the rows. If multiple vectors or a 2D matrix     is supplied, an evaluation is performed for each control vector. If not     specified, the initial values from the Everest configuration are used.</li> <li>metadata (<code>dict</code>, optional): A dictionary of metadata to be associated     with each result generated by the evaluator.</li> </ul>"},{"location":"usage/basics/#add_store","title":"<code>add_store</code>","text":"<p>Adds a result store to the plan to record the progress of a step. The resulting <code>EverestStore</code> object stores results emitted by optimizers and evaluators that it is monitoring. It accepts the following arguments:</p> <ul> <li>steps: A single step object or a list of step objects to track. The     tracker will only record results generated by the specified steps.</li> </ul> <p>The tracker object returned by <code>add_store</code> supports the following properties to inspect the results that it stores:</p> <ul> <li><code>results</code>:  The list of results that   is stored.</li> <li><code>controls</code>: The controls in the   stored results.</li> </ul> <p>In addition, the following methods are available:</p> <ul> <li><code>reset</code>: Reset the tracker to contain     no results.</li> <li><code>dataframe</code>: Export the results     as Pandas data frames.</li> </ul>"},{"location":"usage/basics/#add_tracker","title":"<code>add_tracker</code>","text":"<p>Adds a result tracker to the plan to monitor the progress of a step. The resulting <code>EverestTracker</code> object tracks and stores results emitted by optimizers and evaluators that it is monitoring. It accepts the following arguments:</p> <ul> <li>steps: A single step object or a list of step objects to track. The     tracker will only record results generated by the specified steps.</li> <li>what: This argument determines which results the tracker should     record. Possible values:<ul> <li><code>\"best\"</code>: Only the best result found so far is tracked. This is the default.</li> <li><code>\"last\"</code>: Only the most recently generated result is tracked.</li> </ul> </li> <li>constraint_tolerance: A tolerance for detecting constraint violations.</li> </ul> <p>The tracker object returned by <code>add_tracker</code> supports the following properties to inspect the results that it stores:</p> <ul> <li><code>results</code>:  The results object that   is stored.</li> <li><code>controls</code>: The controls in the   stored results.</li> </ul> <p>In addition, the following methods are available:</p> <ul> <li><code>reset</code>: Reset the tracker to contain     no results.</li> <li><code>dataframe</code>: Export the results     as Pandas data frames.</li> </ul>"},{"location":"usage/basics/#add_cache","title":"<code>add_cache</code>","text":"<p>The <code>add_cache</code> method adds a cache object to the plan. The resulting <code>EverestCachedEvaluator</code> object can be used prevent unnecessary re-evaluation of controls that have already were evaluated before. It takes the following two arguments:</p> <ul> <li>steps: A step, or a sequence of steps that can make use of the cache object.</li> <li>source: The event handlers to use by the cache object.</li> </ul>"},{"location":"usage/basics/#add_table","title":"<code>add_table</code>","text":"<p>Adds a table event handler to the plan. The resulting <code>EverestTableHandler</code> object tracks and stores results emitted by optimizers and evaluators in tables on file. It accepts a single argument:</p> <ul> <li>steps: A single step object or a list of step objects to track. The     tracker will only record results generated by the specified steps.</li> </ul>"},{"location":"usage/everest_config/","title":"Everest configuration","text":""},{"location":"usage/everest_config/#modifying-everest-configuration-settings","title":"Modifying Everest Configuration Settings","text":"<p>Within the <code>run_plan</code> function you will usually load an Everest configuration using the <code>load_config</code> function. This configuration can be modified before running any optimization or evaluation steps. However, it's important to note that not all modifications will necessarily take effect, and some may lead to unexpected behavior. Currently, it's considered safe to modify most settings within the <code>optimization</code> section, as well as the <code>realization_weights</code> in the <code>model</code> section.</p>"},{"location":"usage/everest_config/#handling-max_batch_num","title":"Handling <code>max_batch_num</code>","text":"<p>Modifying the <code>max_batch_num</code> setting within the <code>optimization</code> section after the plan has started will have no effect. It's crucial to understand that <code>max_batch_num</code> determines the total number of batches allowed across the entire optimization process. Consequently, if your <code>run_plan</code> function includes multiple optimization runs, and the first run reaches the <code>max_batch_num</code> limit, subsequent optimization steps will not be executed.</p>"},{"location":"usage/examples/","title":"Examples","text":"<p>It is recommended to run these examples directly using this script template, so that output is printed to the console:</p> <pre><code>from ropt_everest import load_config, run_everest\n\ndef run_plan(plan):\n    ...\n\nif __name__ == \"__main__\":\n    import warnings\n\n    warnings.filterwarnings(\"ignore\")\n    run_everest(\"config_example.yml\")\n</code></pre>"},{"location":"usage/examples/#basic-plan","title":"Basic plan","text":"<p>A basic plan that corresponds to the default Everest optimization:</p> <pre><code>def run_plan(plan):\n    config = load_config(\"config_example.yml\")\n    optimizer = plan.add_optimizer()\n    plan.add_table(optimizer)\n    optimizer.run(config)\n</code></pre>"},{"location":"usage/examples/#running-two-optimizers","title":"Running two optimizers","text":"<p>Running two optimizers, sending optimizer output to different directories:</p> <pre><code>def run_plan(plan):\n    config = load_config(\"config_example.yml\")\n    optimizer = plan.add_optimizer()\n    tracker = plan.add_tracker(optimizer)\n    plan.add_table(optimizer)\n\n    print(\"Running first optimizer...\")\n    optimizer.run(config=config, output_dir=\"output1\")\n\n    print(\"Running second optimizer...\")\n    optimizer.run(config=config, controls=tracker.controls, output_dir=\"output2\")\n</code></pre>"},{"location":"usage/examples/#running-optimizers-in-a-loop","title":"Running optimizers in a loop","text":"<p>Run an optimizer in a loop, each time starting from the last result of the previous. Add the tracker that stores the last value to the plan as a cache. Store all results in memory and export the simulations of all to a Pandas data frame. In addition, add the index of the loop to the metadata, which an additional <code>iteration</code> column to the data frame:</p> <pre><code>def run_plan(plan):\n    config = load_config(\"config_example.yml\")\n    optimizer = plan.add_optimizer()\n    tracker = plan.add_tracker(optimizer, what=\"last\")\n    store = plan.add_store(optimizer)\n    plan.add_cache(steps=optimizer, sources=tracker)\n\n    for idx in range(3):\n        optimizer.run(\n            config,\n            controls=tracker.controls,\n            metadata={\"iteration\": idx},\n            output_dir=f\"output{idx}\",\n        )\n    print(store.dataframe(\"simulations\"))\n</code></pre>"},{"location":"usage/examples/#running-an-evaluation","title":"Running an evaluation","text":"<p>Run an evaluation of the function for two control vectors and export the results to a Pandas data frame:</p> <pre><code>def run_plan(plan):\n    config = load_config(\"config_example.yml\")\n    evaluator = plan.add_ensemble_evaluator()\n    store = plan.add_store(evaluator)\n    evaluator.run(config, controls=[[0, 0, 0], [0.25, 0.25, 0.25], [1, 1, 1]])\n    print(store.dataframe(\"results\"))\n</code></pre>"},{"location":"usage/running/","title":"Running the plan","text":"<p>Typically, Everest optimization workflows are executed using the standard Everest command-line interface (CLI). This approach works seamlessly even when you've implemented a custom <code>run_plan</code> function using <code>ropt-everest</code>. However, the Everest CLI often obscures exceptions and errors, providing limited feedback or relegating detailed information to log files. This can be cumbersome during the development of a custom <code>run_plan</code> function, as not all exceptions are immediately visible. Moreover, the standard Everest CLI redirects standard output (stdout) and standard error (stderr) to files, which can further complicate debugging.</p> <p>To address these challenges, <code>ropt-everest</code> offers the <code>run_everest</code> function. This function allows you to execute an Everest optimization directly, bypassing the Everest CLI. Instead of launching a separate server process in the background or on a cluster, as the Everest CLI typically does, the <code>run_everest</code> method runs the optimization directly within your current process. A key benefit of this is that anything written to <code>stdout</code> or <code>stderr</code> is sent directly to your console.</p> <p>Example: Custom <code>run_plan</code> and Direct Execution</p> <p>Here's an example of a Python module that customizes the optimization process. When placed in the same directory as an Everest configuration file (YAML) and given the same base name, this module will be used by Everest. It can also be directly executed as a Python script to run the workflow without the Everest CLI:</p> <pre><code>from ropt_everest import load_config, run_everest\n\n\ndef run_plan(plan):\n    config = load_config(\"config.yml\")\n    optimizer = plan.add_optimizer()\n    plan.add_table(optimizer)\n    optimizer.run(config)\n\n\nif __name__ == \"__main__\":\n    import warnings\n\n    warnings.filterwarnings(\"ignore\")\n    run_everest(\"config.yml\")\n</code></pre> <p>Here, within the <code>if __name__ == \"__main__\":</code> block, we first suppress warnings that Everest might produce. These warnings are generally intended for end-users and are typically not relevant during the development of a custom <code>run_plan</code> function. We then execute the <code>run_everest</code> function, passing the path to the configuration file.</p> <p>This assumes that the script has the same base name as the configuration file, and is located in the same directory. You can use a different name, but then you have to specify both the names of the configuration and script in the <code>run_everest</code> call:</p> <pre><code>from ropt_everest import load_config, run_everest\n\n\ndef run_plan(plan):\n    config = load_config(\"config.yml\")\n    optimizer = plan.add_optimizer()\n    plan.add_table(optimizer)\n    optimizer.run(config)\n\n\nif __name__ == \"__main__\":\n    import warnings\n\n    warnings.filterwarnings(\"ignore\")\n    run_everest(\"config.yml\", script=__file__)\n</code></pre> <p>Note: Running on a HPC cluster</p> <p>The standard Everest command interface runs the optimization as a separate server process. If Everest is configured for an HPC cluster, this server process, which manages the optimization, is submitted to and executes on the cluster.</p> <p>In contrast, the direct execution method (<code>run_everest</code>) runs the optimization within the current Python process. Consequently, the optimization executes on the machine where your script is run (e.g., a login node or your local machine), not automatically on an HPC cluster compute node. This is true even if Everest is configured to use the cluster for other tasks, such as forward model evaluations.</p> <p>Importantly, regardless of how the optimization process itself is launched (standard CLI or direct execution), forward model evaluations managed by Everest will still be submitted to the HPC cluster if Everest is configured to do so.</p> <p>If you intend for the main optimization process (when using direct execution via <code>run_everest</code>) to also run on an HPC cluster, you must explicitly submit your Python script to the cluster. This is done using standard cluster job submission procedures, such as creating a batch script for schedulers like SLURM or PBS.</p>"}]}