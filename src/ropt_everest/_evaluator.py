from __future__ import annotations

from pathlib import Path
from typing import TYPE_CHECKING, Any

from everest.config import EverestConfig
from everest.optimizer.everest2ropt import everest2ropt
from everest.optimizer.opt_model_transforms import get_optimization_domain_transforms
from ropt.config import EnOptConfig
from ropt.enums import ExitCode
from ropt.plugins.compute_step.ensemble_evaluator import (
    DefaultEnsembleEvaluatorComputeStep,
)
from ropt.transforms import OptModelTransforms
from ropt.workflow import create_compute_step

from ._handler_mixin import HandlerMixin

if TYPE_CHECKING:
    from numpy.typing import ArrayLike
    from ropt.enums import ExitCode
    from ropt.plugins.evaluator.base import Evaluator


class EverestEnsembleEvaluator(HandlerMixin, DefaultEnsembleEvaluatorComputeStep):
    """The Everest ensemble evaluator class.

    This  class evaluates an ensemble for one or more control values via the
    default Everest code path. An `EverestEnsembleEvaluator` object is most
    conveniently created via the
    [`create_ensemble_evaluator`][ropt_everest.create_ensemble_evaluator]
    function.

    Call [`run`][ropt_everest.EverestEnsembleEvaluator.run] method to execute
    the evaluator. Refer the the documentation of the
    [`HandlerMixin`][ropt_everest.HandlerMixin] class for more information on methods
    that are used to add event handlers to an ensemble evaluator.
    """

    def __init__(self, *, evaluator: Evaluator) -> None:
        """Initialize a default optimizer.

        Args:
            evaluator: The evaluator object to run function evaluations.
        """
        super().__init__(evaluator=evaluator)

    def run(  # type: ignore[override]
        self,
        config: dict[str, Any],
        *,
        controls: ArrayLike | None = None,
        metadata: dict[str, Any] | None = None,
        output_dir: str | None = None,
    ) -> ExitCode:
        """Runs the ensemble evaluator.

        This method executes the underlying ensemble evaluator with the given
        parameters:

        **config**: The `config` dictionary should be a dictionary that can be validated
        as an `EverestConfig` object.

        **controls**: The `controls` parameter can be a single vector, a
        sequence of multiple vectors, or a 2D matrix where the control vectors
        are the rows. If no controls are provided, the evaluator will use the
        initial values from the configuration.

        **metadata**: The `metadata` parameter allows you to associate arbitrary
        data with each result generated by the evaluator. This metadata is
        included in generated tables and data frames. The keys in the `metadata`
        dictionary are used as column names in the output tables.

        **optimization_output**: Normally, the optimizer's output is directed to
        the `optimization_output` subdirectory within the main output directory
        specified in the Everest configuration. When multiple optimization or
        ensemble evaluation steps are executed, there's a risk of output files
        being overwritten. The `output_dir` argument provides a way to override
        the default output location. You can specify an absolute path, or a
        relative path, which will be interpreted as relative to the
        `optimization_output` directory.

        Args:
            config:     An optional dictionary containing the Everest
                        configuration. If omitted, the default configuration is
                        used.
            controls:   An array-like object containing the controls to evaluate.
            metadata:   An optional dictionary of metadata to associate with the
                        results.
            output_dir: An optional output directory.
        """
        everest_config = EverestConfig.with_plugins(config)
        config_dict, initial_values = everest2ropt(
            [control.to_ert_parameter_config() for control in everest_config.controls],
            everest_config.create_ert_objectives_config(),
            everest_config.input_constraints,
            everest_config.create_ert_output_constraints_config(),
            everest_config.optimization,
            everest_config.model,
            everest_config.environment.random_seed,
            everest_config.optimization_output_dir,
        )

        if output_dir is not None:
            output_path = Path(output_dir)
            if not output_path.is_absolute():
                output_path = config_dict["optimizer"]["output_dir"] / output_path
            config_dict["optimizer"]["output_dir"] = output_path
            output_path.mkdir(parents=True, exist_ok=True)

        enopt_config = EnOptConfig.model_validate(config_dict)

        everest_transforms = get_optimization_domain_transforms(
            [control.to_ert_parameter_config() for control in everest_config.controls],
            everest_config.create_ert_objectives_config(),
            everest_config.input_constraints,
            everest_config.create_ert_output_constraints_config(),
            everest_config.model,
            auto_scale=everest_config.optimization.auto_scale,
        )

        transforms = (
            OptModelTransforms(
                variables=everest_transforms["control_scaler"],
                objectives=everest_transforms["objective_scaler"],
                nonlinear_constraints=everest_transforms["constraint_scaler"],
            )
            if everest_transforms
            else None
        )

        return super().run(
            config=enopt_config,
            transforms=transforms,
            metadata=metadata,
            variables=initial_values if controls is None else controls,
        )


def create_ensemble_evaluator(evaluator: Evaluator) -> EverestEnsembleEvaluator:
    """Create an ensemble evaluator.

    Invoking this function returns an
    [`EverestEnsembleEvaluator`][ropt_everest.EverestEnsembleEvaluator] object,
    which you can execute using its
    [`run`][ropt_everest.EverestEnsembleEvaluator.run] method.

    Returns:
        An `EverestEnsembleEvaluator` object, representing the added evaluator.
    """
    step = create_compute_step("everest/ensemble_evaluator", evaluator=evaluator)
    assert isinstance(step, EverestEnsembleEvaluator)
    return step
