from __future__ import annotations

from copy import deepcopy
from typing import TYPE_CHECKING

from ropt.plugins.event_handler._store import DefaultStoreHandler
from ropt.results import FunctionResults, GradientResults, Results, results_to_dataframe

from ._utils import TABLE_COLUMNS, TABLE_TYPE_MAP, fix_columns, reorder_columns

if TYPE_CHECKING:
    import numpy as np
    import pandas as pd
    from numpy.typing import NDArray


class EverestStoreHandler(DefaultStoreHandler):
    """Provides access to the results generated by optimizers and evaluators.

    This class provides methods to retrieve and analyze the results produced
    within an Everest workflow. It allows you to access the results. You can
    also convert the stored results into a Pandas DataFrame for easier
    analysis.
    """

    def __init__(self) -> None:
        super().__init__()

    @property
    def results(self) -> list[Results] | None:
        """Retrieves the stored results.

        Returns:
            The stored results.
        """
        assert self["results"] is None or isinstance(self["results"], list)
        return self["results"]

    @property
    def controls(self) -> NDArray[np.float64] | list[NDArray[np.float64]] | None:
        """Retrieves the stored controls.

        Returns:
            The stored controls.
        """
        if self["results"] is None:
            return None
        assert isinstance(self["results"], list)
        return [
            item.evaluations.variables
            for item in self["results"]
            if isinstance(item, (FunctionResults, GradientResults))
        ]

    def reset(self) -> None:
        """Reset the store.

        Clears any results accumulated so far.
        """
        self["results"] = None

    def dataframe(self, kind: str) -> pd.DataFrame | None:
        """Converts the stored results to a Pandas DataFrame.

        This method converts the tracked results into a Pandas DataFrame, making
        it easier to analyze and visualize the data.

        The `kind` argument supports the following options:

        - `"results"`:       For function results.
        - `"gradients"`:     For gradient results.
        - `"simulations"`:   For simulation results.
        - `"perturbations"`: For perturbation results.
        - `"constraints"`:   For constraint information.

        Note:
            The column names of the dataframe may be strings or tuples of
            strings. In the tuple form, the name is usually composed of a string
            indicating the type of column and one or more objective, constraint
            or control names. For instance, a column containing values of the
            control `point.x` may have the name: `(controls, point.x)`. The
            gradient of an objective `distance` with respect to a control
            `point.x` may have the column name `(objectives, distance, point.x.0)`.

        Args:
            kind: The type of table to create.

        Returns:
            A Pandas DataFrame containing the store results, or None.
        """
        if kind not in TABLE_COLUMNS:
            msg = f"Cannot make frame for `{kind}`"
            raise RuntimeError(msg)
        if self["results"] is not None:
            columns = deepcopy(TABLE_COLUMNS[kind])
            if self["results"][0].metadata is not None:
                for item in self["results"][0].metadata:
                    columns[f"metadata.{item}"] = item
            return fix_columns(
                reorder_columns(
                    results_to_dataframe(
                        self["results"],
                        fields=set(columns),
                        result_type=TABLE_TYPE_MAP[kind],
                    ),
                    columns,
                )
            )
        return None
