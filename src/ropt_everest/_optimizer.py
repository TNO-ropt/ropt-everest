from __future__ import annotations

from pathlib import Path
from typing import TYPE_CHECKING, Any

from everest.config import EverestConfig
from everest.optimizer.everest2ropt import everest2ropt
from everest.optimizer.opt_model_transforms import get_optimization_domain_transforms
from ropt.config import EnOptConfig
from ropt.enums import ExitCode
from ropt.plugins.compute_step.optimizer import DefaultOptimizerComputeStep
from ropt.transforms import OptModelTransforms
from ropt.workflow import create_compute_step

from ._step_mixin import StepMixin

if TYPE_CHECKING:
    from numpy.typing import ArrayLike
    from ropt.enums import ExitCode
    from ropt.plugins.evaluator.base import Evaluator


class EverestOptimizerStep(StepMixin, DefaultOptimizerComputeStep):
    def __init__(self, *, evaluator: Evaluator) -> None:
        """Initialize a default optimizer.

        Args:
            evaluator: The evaluator object to run function evaluations.
        """
        super().__init__(evaluator=evaluator)

    def run(  # type: ignore[override]
        self,
        config: dict[str, Any],
        *,
        controls: ArrayLike | None = None,
        metadata: dict[str, Any] | None = None,
        output_dir: str | None = None,
    ) -> ExitCode:
        """Runs the optimizer.

        This method executes the optimizer with the given parameters.

        **Configuration**:

        - The `config` dictionary should be a dictionary that can be validated
          as an `EverestConfig` object.

        **Controls**:

        If no controls are provided, the optimizer will use the initial values
        from the configuration.

        **Metadata**:

        - The `metadata` parameter allows you to associate arbitrary data with
          each result generated by the optimizer or ensemble evaluators.
        - This metadata is included in generated tables and data frames.
        - The keys in the `metadata` dictionary are used as column names in
          the output tables.

        **Optimizer output**:

        Normally, the optimizer's output is directed to the `optimization_output`
        subdirectory within the main output directory specified in the Everest
        configuration. When multiple optimization steps are executed, there's a
        risk of output files being overwritten. The `output_dir` argument
        provides a way to override the default output location for the optimizer.
        You can specify an absolute path, or a relative path, which will be
        interpreted as relative to the `optimization_output` directory.

        Args:
            config:     An optional dictionary containing the Everest configuration
                        for the optimizer. If omitted, the default configuration is
                        used.
            controls:   An array-like object containing the controls for the optimization.
            metadata:   An optional dictionary of metadata to associate with the
                        results of the optimizer's results.
            output_dir: An optional output directory for the optimizer.
        """
        everest_config = EverestConfig.with_plugins(config)
        config_dict, initial_values = everest2ropt(
            [control.to_ert_parameter_config() for control in everest_config.controls],
            everest_config.create_ert_objectives_config(),
            everest_config.input_constraints,
            everest_config.create_ert_output_constraints_config(),
            everest_config.optimization,
            everest_config.model,
            everest_config.environment.random_seed,
            everest_config.optimization_output_dir,
        )

        if output_dir is not None:
            output_path = Path(output_dir)
            if not output_path.is_absolute():
                output_path = config_dict["optimizer"]["output_dir"] / output_path
            config_dict["optimizer"]["output_dir"] = output_path
            output_path.mkdir(parents=True, exist_ok=True)

        enopt_config = EnOptConfig.model_validate(config_dict)

        everest_transforms = get_optimization_domain_transforms(
            [control.to_ert_parameter_config() for control in everest_config.controls],
            everest_config.create_ert_objectives_config(),
            everest_config.input_constraints,
            everest_config.create_ert_output_constraints_config(),
            everest_config.model,
            auto_scale=everest_config.optimization.auto_scale,
        )

        transforms = (
            OptModelTransforms(
                variables=everest_transforms["control_scaler"],
                objectives=everest_transforms["objective_scaler"],
                nonlinear_constraints=everest_transforms["constraint_scaler"],
            )
            if everest_transforms
            else None
        )

        return super().run(
            config=enopt_config,
            transforms=transforms,
            metadata=metadata,
            variables=initial_values if controls is None else controls,
        )


def create_optimizer(evaluator: Evaluator) -> EverestOptimizerStep:
    """Creates an optimizer.

    This function returns an
    [`EverestOptimizerStep`][ropt_everest.EverestOptimizerStep] object, which
    you can execute using its [`run`][ropt_everest.EverestOptimizerStep.run]
    method.

    Returns:
        An `EverestOptimizerStep` object, representing the added optimizer.
    """
    step = create_compute_step("everest/optimizer", evaluator=evaluator)
    assert isinstance(step, EverestOptimizerStep)
    return step
