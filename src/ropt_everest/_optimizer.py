from __future__ import annotations

from pathlib import Path
from typing import TYPE_CHECKING, Any

from ropt.config import EnOptConfig
from ropt.enums import ExitCode
from ropt.plugins.compute_step.optimizer import DefaultOptimizerComputeStep
from ropt.transforms import OptModelTransforms
from ropt.workflow import create_compute_step

from ._handler_mixin import HandlerMixin

if TYPE_CHECKING:
    from numpy.typing import ArrayLike
    from ropt.enums import ExitCode
    from ropt.plugins.evaluator.base import Evaluator

# ruff: noqa: PLC0415


class EverestOptimizer(HandlerMixin, DefaultOptimizerComputeStep):
    """The Everest optimizer class.

    This  class executes an optimization via the default Everest code path. An
    `EverestOptimizer` object is most conveniently created via the
    [`create_optimizer`][ropt_everest.create_optimizer] function.

    Call [`run`][ropt_everest.EverestOptimizer.run] method to execute the
    optimizer. Refer the the documentation of the
    [`HandlerMixin`][ropt_everest.HandlerMixin] class for more information on methods
    that are used to add event handlers to an optimizer.
    """

    def __init__(self, *, evaluator: Evaluator) -> None:
        """Initialize an Everest optimizer.

        Args:
            evaluator: The evaluator object to run function evaluations.
        """
        super().__init__(evaluator=evaluator)

    def run(  # type: ignore[override]
        self,
        config: dict[str, Any],
        *,
        controls: ArrayLike | None = None,
        metadata: dict[str, Any] | None = None,
        output_dir: str | None = None,
    ) -> ExitCode:
        """Runs the optimizer.

        This method executes the optimizer with the given parameters.

        **config**: The `config` dictionary should be a dictionary that can be validated
        as an `EverestConfig` object.

        **controls**: If no controls are provided, the optimizer will use the
        initial values
        from the configuration.

        **metadata**: The `metadata` parameter allows you to associate arbitrary
        data with each result generated by the evaluator. This metadata is
        included in generated tables and data frames. The keys in the `metadata`
        dictionary are used as column names in the output tables.

        **optimization_output**: Normally, the optimizer's output is directed to
        the `optimization_output` subdirectory within the main output directory
        specified in the Everest configuration. When multiple optimization or
        ensemble evaluation steps are executed, there's a risk of output files
        being overwritten. The `output_dir` argument provides a way to override
        the default output location. You can specify an absolute path, or a
        relative path, which will be interpreted as relative to the
        `optimization_output` directory.

        Args:
            config:     An optional dictionary containing the Everest
                        configuration. If omitted, the default configuration is
                        used.
            controls:   An array-like object containing the controls for the optimization.
            metadata:   An optional dictionary of metadata to associate with the
                        results.
            output_dir: An optional output directory.

        Returns:
            The exit code of the optimizer.
        """
        from everest.config import EverestConfig
        from everest.optimizer.everest2ropt import everest2ropt
        from everest.optimizer.opt_model_transforms import (
            get_optimization_domain_transforms,
        )

        everest_config = EverestConfig.with_plugins(config)
        config_dict, initial_values = everest2ropt(
            [control.to_ert_parameter_config() for control in everest_config.controls],
            everest_config.create_ert_objectives_config(),
            everest_config.input_constraints,
            everest_config.create_ert_output_constraints_config(),
            everest_config.optimization,
            everest_config.model,
            everest_config.environment.random_seed,
            everest_config.optimization_output_dir,
        )

        if output_dir is not None:
            output_path = Path(output_dir)
            if not output_path.is_absolute():
                output_path = config_dict["optimizer"]["output_dir"] / output_path
            config_dict["optimizer"]["output_dir"] = output_path
            output_path.mkdir(parents=True, exist_ok=True)

        enopt_config = EnOptConfig.model_validate(config_dict)

        everest_transforms = get_optimization_domain_transforms(
            [control.to_ert_parameter_config() for control in everest_config.controls],
            everest_config.create_ert_objectives_config(),
            everest_config.input_constraints,
            everest_config.create_ert_output_constraints_config(),
            everest_config.model,
            auto_scale=everest_config.optimization.auto_scale,
        )

        transforms = (
            OptModelTransforms(
                variables=everest_transforms["control_scaler"],
                objectives=everest_transforms["objective_scaler"],
                nonlinear_constraints=everest_transforms["constraint_scaler"],
            )
            if everest_transforms
            else None
        )

        return super().run(
            config=enopt_config,
            transforms=transforms,
            metadata=metadata,
            variables=initial_values if controls is None else controls,
        )


def create_optimizer(evaluator: Evaluator) -> EverestOptimizer:
    """Creates an optimizer.

    This function returns an
    [`EverestOptimizer`][ropt_everest.EverestOptimizer] object, which
    you can execute using its [`run`][ropt_everest.EverestOptimizer.run]
    method.

    Returns:
        An `EverestOptimizer` object, representing the added optimizer.
    """
    step = create_compute_step("everest/optimizer", evaluator=evaluator)
    assert isinstance(step, EverestOptimizer)
    return step
